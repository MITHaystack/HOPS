file   = MHO_task_0210.txt
domain = @PROTO

# Prototyping tasks
thing  = @ProtoCode

task   = Prototype the new data containers
nick   = ProtoCode-containers
@cpptask
desc   = Create a set of C++ classes that define the new data containers
#needs  = SpecsDocs-draft
needs  = Miles-repo

task   = Test the performance of the new data containers
nick   = ProtoCode-containertest
desc   = Profile the memory performance of the new data containers
code   = C
#start  = tSREV
needs  = ProtoCode-containers
#allows = Meetings-endQ08

task   = Prototype the SWIG bindings
nick   = ProtoCode-swigexample
@pytask
desc   = Write the compilation steps for the SWIG bindings in the autmake tools
needs  = Miles-repo
who    = @gc

task   = Test the SWIG bindings
nick   = ProtoCode-swigtest
@pytask
desc   = Check that the SWIG bindings work with the new data containers,
         move arrays information back and forth between the containers
         and the python
needs  = ProtoCode-swigexample,ProtoCode-containers
start  = 2021-03-17
days   = 14
derate = 1
#allows = Meetings-endQ08
who    = @dh

task   = Prototype fringe plot without PGPLOT
nick   = ProtoCode-fringeplot
desc   = Demonstrate that we can make a fringe plot with matplotlib
code   = Python
#start  = tJHIRE
needs  = Miles-repo
#needs  = Meetings-hired
who    = @dh

task   = Test an interactive plotting GUI
nick   = ProtoCode-interactivefringeplot
desc   = Demonstrate interactive plotting tools with matplotlib
code   = Python
needs  = ProtoCode-fringeplot
#allows = Meetings-endQ08
who    = @dh


task   = Review the prototypes of the new functionality
nick   = ProtoCode-review
@gentask
desc   = Milestone to review the code prototypes. By this point we should have measured
	 the performance of the data containers, understood the binding methods, and
	 demonstrated new fringeplot tools.
needs  = ProtoCode-fringeplot,ProtoCode-swigtest,ProtoCode-containertest
start  = @tQ07E
days   = 7
derate = 1



thing  = IOstream

task   = Design the UUID header for the HOPS4 binary file format
nick   = IOStream-header
@cpptask
desc   = The header of the native file format should contain some
         number of bytes that facilitate file reads. This should
         define data type, data size, and maybe a few other things
         like datatype version. How many bytes do we need and how
         to organize them?
needs  = Miles-repo
start  = 2021-03-22
days   = 5
derate = 1
who    = @jb


task   = Implement binary file interface
nick   = IOStream-interface
@cpptask
desc   = 
needs  = IOStream-header
days   = 5
derate = 1
who    = @jb

task   = Apply to data containers
nick   = IOStream-containers
@cpptask
desc   = 
needs  = IOStream-interface
days   = 5
derate = 1
who    = @jb


