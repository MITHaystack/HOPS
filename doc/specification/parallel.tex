
\section{Parallel processing}
\label{sec:parallel}

The existing fringe-fitting process is largely a data-parallel process operating on individual baselines with no inter-process
communication. This lends itself easily to simple parallelism using multiple independent processes (SPMD), which has been exploited
\cite{blackburn2019eht} to deal with the EHT data volume. However, this approach eliminates the ability to simultaneously fit for global or station-based
parameters and requires multiple iterations in order to apply successive calibration/corrections. Therefore, if some calibration tasks are to be
done simultaneously with fringe-fringe fitting, this will require both a substantial architectural change from the current fitting algorithm, but
also necessarily reduce the degree of (simple) parallelism available. To accommodate this, some parallel processing will have to be addressed
within the application. To do this we will use a multi-staged approach during the course of development.

Initially, the software to be developed under this project will focus on a simple single-threaded implementation, whereupon careful
profiling will inform us of the largest computational bottlenecks. For example, in the current HOPS code the majority of
the computation time is spent in a single routine (vrot.c, which is essentially just evaluating a complex exponential and multiplying two complex numbers) that is applied over
a large array of data. This sort of task can easily be parallelized on modern multi-core architectures using the SIMD approach. We propose to use OpenCL
for this purpose given its support on a wide variety of architectures (multi-core CPUs, GPUS, hardware accelerators, etc.).

OpenCL extensions for various data operations will be inherit from the operator templates described in listing \ref{lst:operators} and make use of the data container extension mechanism described in \ref{lst:extend}. This will allow them to function as drop-in replacements for single-threaded operators (in use within compound operators) that can be enabled when the underlying hardware is present. For example, lets consider the task of performing a scaling operation on a large array. Normally, this is trivially implemented in single-threaded fashion with a simple for-loop. However, OpenCL can be exploited to apply the scale factor across large chunks of the array in parallel. To do this, a container object is first extended with an OpenCL buffer object (by the operator). The device buffer is then populated with the host data and the SIMD implementation of the data operation is executed by the device. If desired, the results can be transferred back to the host, or can remain on the device side buffer for immediate use if the next operation also happens to be an OpenCL enabled operator. This process is all hidden behind the public interface of the data operators (listing \ref{lst:operators}) using (\texttt{SetArgs(...)}, \texttt{Initialize(...)}, and \texttt{Execute(...)}), so SIMD enabled operators and standard single-thread operators can be made interchangeable.


SIMD parallelism exploits vector instructions and/or multiple processors to execute the similar operations over wide swaths of data. While given current experience with the existing HOPS leads us to expect that SIMD parallelism should largely be adequate to accelerate fringe fitting, if during the process of development it is discovered that a thread-based model (MIMD, where each parallel thread follows a semi-independent code pathway) could be more advantageous, then we propose to use OpenMPI framework to implement this. The reason being, that while OpenMPI does have a larger development overhead than most other threading libraries (e.g. pthreads, c++11 threads, etc.) it can be easily scaled beyond a single computer when and if needed. However, it should be noted that by necessity, any OpenMPI implementation must be developed as an independent executable (although it would also be able to take advantage of any available libraries and SIMD policies present if the underlying hardware supports it). 
